%% 注意：在论文写作中，应该先对判断矩阵进行一致性检验，然后再计算权重，因为只有判断矩阵通过了一致性检验，其权重才是有意义的。

%% 在下面的代码中，我们先计算了权重，然后再进行了一致性检验，这是为了顺应计算过程，事实上在逻辑上是说不过去的。

%% 因此大家自己写论文中如果用到了层次分析法，一定要先对判断矩阵进行一致性检验。

%% 而且要说明的是，只有非一致矩阵的判断矩阵才需要进行一致性检验。

%% 如果你的判断矩阵本身就是一个一致矩阵，那么就没有必要进行一致性检验。


% 在每一行的语句后面加上分号（一定要是英文的哦; 中文的长这个样子；）表示不显示运行结果
% 多行注释：选中要注释的若干语句，快捷键 Ctrl + R
% 取消注释：选中要取消注释的语句，快捷键 Ctrl + T

disp('请输入判断矩阵 A') % MATLAB 中 disp() 就是屏幕输出函数，类似于 C 语言中的 printf() 函数
% 注意，disp 函数比较特殊，这里可要分号，可不要分号

A = input('A =');
% 这里输入的就是我们的判断矩阵，其为 n 阶方阵（行数和列数相同）
% [1 3 1/3 1/3 1 1/3; 1/3 1 1/4 1/5 1 1/5; 3 4 1 1 2 3; 3 5 1 1 2 1; 1 1 1/2 1/2 1 1; 3 5 1/3 1 1 1]
% [1 1 4 1/3 3; 1 1 4 1/3 3; 1/4 1/4 1 1/3 1/2; 3 3 3 1 3; 1/3 1/3 2 1/3 1]

% 在开始下面正式的步骤之前，我们有必要检验下 A 是否因为粗心而输入有误
ERROR = 0; % 默认输入是没有错误的
% （1）检查矩阵 A 的维数是否不大于 1 或不是方阵
[r, c] = size(A);
% size(A) 函数是用来求矩阵的大小的,返回一个行向量，第一个元素是矩阵的行数，第二个元素是矩阵的列数
% [r, c] = size(A)  % 将矩阵 A 的行数返回到第一个输出变量 r，将矩阵的列数返回到第二个输出变量 c

if r ~= c || r <= 1
    % 注意，不等号是 ~=  (~是键盘 Tab 上面那个键，要和 Shift 键同时按才会出来)，别和 C 语言里面的 != 搞混了
    % || 表示逻辑运算符"或"（在键盘 Enter 上面，也要和 Shift 键一起按），逻辑运算符"且"是 && （& 读 and，连接符号，是 and 的缩写。）
    ERROR = 1;
end
% MATLAB 的判断语句，if 所在的行不需要冒号，语句的最后一定要以 end 结尾；中间的语句要注意缩进。

% （2）检验是否为正互反矩阵 a_ij > 0 且 a_ij * a_ji = 1
if ERROR == 0
    [n, n] = size(A);
    % 因为我们的判断矩阵 A 是一个非零方阵，所以这里的 r 和 c 相同，我们可以就用同一个字母 n 表示
    % 判断是否有元素小于 0
    % for i = 1:n
    %     for j = 1:n
    %         if A(i, j) <= 0
    %             ERROR = 2;
    %         end
    %     end
    % end
    if sum(sum(A <= 0)) > 0
        ERROR = 2;
    end
end

% 顺便检验 n 是否超过了 15，因为 RI 向量为 15 维
if ERROR == 0
    if n > 15
        ERROR = 3;
    end
end

if ERROR == 0
    % 判断  a_ij * a_ji = 1 是否成立
    if sum(sum(A'.*A ~= ones(n))) > 0
        ERROR = 4;
    end
    % A' 表示求出 A 的转置矩阵，即将 a_ij 和 a_ji 互换位置
    % ones(n) 函数生成一个 n * n 的全为 1 的方阵, zeros(n) 函数生成一个 n * n 的全为 0 的方阵
    % ones(m, n) 函数生成一个 m * n 的全为 1 的矩阵
    % MATLAB 在矩阵的运算中，"/"号和"*"号代表矩阵之间的除法与乘法，对应元素之间的乘除法需要使用"./"和“.*”
    % 如果 a_ij * a_ji = 1 满足， 那么 A 和 A' 对应元素相乘应该为 1
end


if ERROR == 0
    % % % % % % % % % % % % % 方法 1：算术平均法求权重 % % % % % % % % % % % % %
    % 第一步：将判断矩阵按照列归一化（每一个元素除以其所在列的和）
    % 第二步：将归一化的各列相加
    % 第三步：将相加后的向量除以 n 即可得到权重向量

    Sum_A = sum(A);
    % MATLAB 中的 sum 函数的用法
    % a=sum(x);  % 按列求和
    % a=sum(x, 2);  % 按行求和
    % a=sum(x(:));  % 对整个矩阵求和

    % % 基础：MATLAB 中如何提取矩阵中指定位置的元素？
    % % （1）取指定行和列的一个元素（输出的是一个值）
    % %     A(2, 1)  A(3, 2)
    % % （2）取指定的某一行的全部元素（输出的是一个行向量）
    % %     A(2, :)  A(5, :)
    % % （3）取指定的某一列的全部元素（输出的是一个列向量）
    % %     A(:, 1)  A(:, 3)
    % % （4）取指定的某些行的全部元素（输出的是一个矩阵）
    % %    A([2, 5], :)      只取第二行和第五行（一共 2 行）
    % %    A(2: 5, :)        取第二行到第五行（一共 4 行）
    % % （5）取全部元素（按列拼接的，最终输出的是一个列向量）
    % %    A(:)

    SUM_A = repmat(Sum_A, n, 1);
    % B = repmat(A, m, n)：将矩阵 A 复制 m × n 块，即把 A 作为 B 的元素，B 由 m × n 个 A 平铺而成。
    % 另外一种替代的方法如下：
    % SUM_A = [];
    % for i = 1:n  % 循环，不需要加冒号，这里表示循环 n 次
    %     SUM_A = [SUM_A; Sum_A];
    % end

    Stand_A = A ./ SUM_A;
    % MATLAB 在矩阵的运算中，"*"号和"/"号代表矩阵之间的乘法与除法，对应元素之间的乘除法需要使用"./"和".*"
    % 这里我们直接将两个矩阵对应的元素相除即可

    disp('算术平均法求权重的结果为：');
    disp(sum(Stand_A, 2)/n)
    % 首先对标准化后的矩阵按照行求和，得到一个列向量，然后再将这个列向量的每个元素同时除以 n 即可（注意这里也可以用 ./）


    % % % % % % % % % % % % % 方法 2：几何平均法求权重 % % % % % % % % % % % % %
    % 第一步：将 A 的元素按照行相乘得到一个新的列向量
    Prduct_A = prod(A, 2);
    % prod 函数和 sum 函数类似，一个用于乘，一个用于加

    % 第二步：将新的向量的每个分量开 n 次方
    Prduct_n_A = Prduct_A.^(1 / n);
    % 这里对元素操作，因此要加 . 号。^符号表示乘方，这里是开 n 次方，所以我们等价求 1 / n 次方

    % 第三步：对该列向量进行归一化即可得到权重向量
    % 将这个列向量中的每一个元素除以这一个向量的和即可
    disp('几何平均法求权重的结果为：');
    disp(Prduct_n_A./sum(Prduct_n_A))


    % % % % % % % % % % % % % 方法3：特征值法求权重 % % % % % % % % % % % % %
    % 计算矩阵A的特征值和特征向量的函数是 eig(A)，其中最常用的两个用法：
    % （1）E=eig(A)：求矩阵 A 的全部特征值，构成向量 E。
    % （2）[V, D] = eig(A)：求矩阵 A 的全部特征值，构成对角阵 D，并求 A 的特征向量构成 V 的列向量。（ V的每一列都是 D 中与之相同列的特征值的特征向量）
    [V, D] = eig(A); % V是特征向量, D 是由特征值构成的对角矩阵（除了对角线元素外，其余位置元素全为 0）
    Max_eig = max(max(D)); % 也可以写成max(D(:))

    % 那么怎么找到最大特征值所在的位置了？需要用到 find 函数，它可以用来返回向量或者矩阵中不为 0 的元素的位置索引。
    % 下面例子来自博客：https://www.cnblogs.com/anzhiwu815/p/5907033.html
    % 关于 find 函数的更加深入的用法可参考原文
    % >> X = [1 0 4 -3 0 0 0 8 6];
    % >> ind = find(X)
    % ind =
    %    1     3     4     8     9
    % 其有多种用法，比如返回前 2 个不为 0 的元素的位置：
    % >> ind = find(X,2)
    % >> ind =
    %     1     3
    % 若 X 是一个矩阵，索引该如何返回呢？
    %  >> X = [1 -3 0;0 0 8;4 0 6]
    %  X =
    %   1    -3     0
    %   0     0     8
    %   4     0     6
    %  >> ind = find(X)
    % ind =
    %      1
    %      3
    %      4
    %      8
    %      9
    % 这是因为在 MATLAB 在存储矩阵时，是一列一列存储的，我们可以做一下验证：
    %  >> X(4)
    %  ans =
    %     -3
    % 假如你需要按照行列的信息输出该怎么办呢？
    % [r,c] = find(X)
    % r =
    %      1
    %      3
    %      1
    %      2
    %      3
    % c =
    %      1
    %      1
    %      2
    %      3
    %      3
    % [r, c] = find(X, 1) % 只找第一个非 0 元素
    % r =
    %      1
    % c =
    %      1

    % 那么问题来了，我们要得到最大特征值的位置，就需要将包含所有特征值的这个对角矩阵 D 中，不等于最大特征值的位置全变为 0
    % 这时候可以用到矩阵与常数的大小判断运算，共有三种运算符：大于 >；小于 <；等于 ==  （一个等号表示赋值；两个等号表示判断）
    % 例如：A > 2 会生成一个和 A 相同大小的矩阵，矩阵元素要么为 0，要么为 1（A 中每个元素和 2 比较，如果大于 2 则为 1，否则为 0）
    [r, c] = find(D == Max_eig, 1);
    % 找到 D 中第一个与最大特征值相等的元素的位置，记录它的行和列。

    disp('特征值法求权重的结果为：');
    disp(V(:, c)./sum(V(:, c)))
    % 我们先根据上面找到的最大特征值的列数 c 找到对应的特征向量，然后再进行标准化。

    % % % % % % % % % % % % % 下面是计算一致性比例 CR 的环节 % % % % % % % % % % % % %
    % 当 CR < 0.10时，我们认为判断矩阵的一致性可以接受；否则应对其进行修正。
    CI = (Max_eig - n) / (n - 1);
    RI = [0, 0.00001, 0.52, 0.89, 1.12, 1.26, 1.36, 1.41, 1.46, 1.49, 1.52, 1.54, 1.56, 1.58, 1.59]; %注意哦，这里的RI最多支持 n = 15
    % 这里 n = 2 时，一定是一致矩阵，所以 CI = 0，我们为了避免分母为 0，将这里的第二个元素改为了很接近 0 的正数
    CR = CI / RI(n);
    disp('一致性指标 CI =');
    disp(CI);
    disp('一致性比例 CR =');
    disp(CR);
    if CR < 0.10
        disp('因为 CR < 0.10，所以该判断矩阵 A 的一致性可以接受！');
    else
        disp('注意：CR >= 0.10，因此该判断矩阵 A 需要进行修改！');
    end
elseif ERROR == 1
    disp('请检查矩阵 A 的维数是否不大于 1 或不是方阵')
elseif ERROR == 2
    disp('请检查矩阵 A 中有元素小于等于 0')
elseif ERROR == 3
    disp('A 的维数 n 超过了 15，请减少准则层的数量')
elseif ERROR == 4
    disp('请检查矩阵 A 中存在 i、j 不满足 A_ij * A_ji = 1')
end

% % 注意：代码文件仅供参考，一定不要直接用于自己的数模论文中
% % 国赛对于论文的查重要求非常严格，代码雷同也算作抄袭